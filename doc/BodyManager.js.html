<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: BodyManager.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: BodyManager.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>class BodyManager {

/**
 * Manages the different bodies within a scene, handling updating, drawing, body iterations. Usually when creating a scene a group of bodies would be created and added to a BodyManager, but bodies can be added or removed dynamically during the scene's playback. A special object of type Viewport can be specified to be used as a camera.
 * @summary View file: {@link https://github.com/GorillaBus/ddw/blob/master/src/class/BodyManager.js https://github.com/GorillaBus/ddw/blob/master/src/class/BodyManager.js}.
 * @constructor
 * @param {Object} settings - Json object with construction options
 * @param {Array} [settings.bodies=[]] - An array of body object to be added on initialization.
 * @param {Viewport} [settings.viewport=null] - A viewport object, generally used as the camera.
 * @param {Drawer} [settings.drawer=0] - A drawer object, used to draw the bodie models on screen.
 * @param {Intersector} settings.intersector - An intersector object.
 * @param {Array} [settings.interactions=[]] - An array of interaction objects.
 */
	constructor(settings) {
		this.debug = settings.debug || false;
		this.bodies = settings.bodies || [];
		this.viewport = null;
		this.drawer = settings.drawer;
		this.intersector = settings.intersector;
		this.interactions = settings.interactions || [];
	}

/**
 * Sets the Viewport object to be used as a view reference or camera.
 * @method
 * @param {Viewport} viewport - A viewport object. 
 */
	setViewport(viewport) {
		this.viewport = viewport;
	}

/**
 * Returns the total amount of managed objects.
 * @method
 * @returns {Int} number of bodies.
 */
	getLength() {
		return this.bodies.length;
	}

/**
 * Adds an array of bodies to the manager.
 * @method
 * @param {Array} bodies - An array of body objects
 */
	add(bodies) {
		this.bodies = this.bodies.concat(bodies);
	}

/**
 * Runs the global update routing that involves updating, transforming and interacting between bodies to update their state in the world. The viewport object is updated but removed from the pipeline before running interactions.
 * @method
 */
	update() {
		for (let j=0,len=this.interactions.length; j&lt;len; j++) this.interactions[j]. resetGrid();
		for (let i=0, len=this.bodies.length; i&lt;len; i++) {
			const body = this.bodies[i];
			body.update();
			body.transformToWorld();
			if (this.viewport &amp;&amp; body.uuid === this.viewport.uuid) continue;
			for (let j=0,len=this.interactions.length; j&lt;len; j++) {
				this.interactions[j].registerBody(body);
			}
		}
	}

/**
 * Iterates through and runs all available interactions between bodies (like gravity, collisions or user interactions).
 * @method
 */
	runInnteractions() {
		for (let i=0,len=this.bodies.length; i&lt;len; i++) {
			const bodyA = this.bodies[i];
			for (let x=0,len=this.bodies.length; x&lt;len; x++) {
				const bodyB = this.bodies[x];
				if (bodyA.uuid === bodyB.uuid) continue;
				bodyA.gravitateTo(bodyB);
			}
		}
		for (let y=0, len=this.interactions.length; y&lt;len; y++) this.interactions[y].run();
	}

/**
 * Returns a body by its id (performing a lookup).
 * @method
 * @param {Int} uuid - The unique id of the requested body.
 * @returns {Body} A body or null if the requested id was not found.
 */
	getBodyById(uuid) {
		for (let i=0,len=this.bodies.length; i&lt;len; i++) {
			if (this.bodies[i].uuid === uuid) {
				return this.bodies[i];
			}
		}
		return null;
	}

/**
 * Draws the bodies based on the desired view type: from 'viewport' or 'world' reference. In the first case it will only draw the bodies that intersect with the Viewport, in the second it will draw all bodies.
 * @method
 * @param {String} viewType - Can be 'viewport' or null for 'world'.
 */
	draw(view) {
		view === 'viewport' ? this.drawViewportTransform() : this.drawWorldTransform();
	}

/**
 * Draws the world-transformed model of each body.
 * @method
 */
	drawWorldTransform() {
		for (let i=0, len=this.bodies.length; i&lt;len; i++) {
			const body = this.bodies[i];
			this.drawer.draw(body.worldTransform.getShapes());
			if (this.debug) {
				this.drawer.drawPolygon(body.worldTransform.boundingBox);
			}
		}
	}

/**
 * Draws the viewport-transformed model of each body that is visible and intersects with the viewport.
 * @method
 */
	drawViewportTransform() {
		const viewportModel = this.viewport.worldTransform.transform(0, 1).boundingBox;
		for (let i=0, len=this.getLength(); i&lt;len; i++) {
			const body = this.bodies[i];
			if (!body.visible) continue;
			const bodyModel = body.worldTransform.boundingBox;
			const intersects = this.intersector.circleInRectangle(bodyModel, viewportModel);
			if (intersects) {
				body.transformToView(this.viewport);
				this.drawer.draw(body.viewTransform.getShapes());
				if (this.debug) {
					this.drawer.drawPolygon(body.viewTransform.boundingBox);
				}
			}
		}
	}
}

module.exports = BodyManager;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Body.html">Body</a></li><li><a href="BodyManager.html">BodyManager</a></li><li><a href="BroadPhaseTester.html">BroadPhaseTester</a></li><li><a href="CollisionInteraction.html">CollisionInteraction</a></li><li><a href="Drawer.html">Drawer</a></li><li><a href="Intersector.html">Intersector</a></li><li><a href="Model.html">Model</a></li><li><a href="Scene.html">Scene</a></li><li><a href="ScenePlayer.html">ScenePlayer</a></li><li><a href="Shape.html">Shape</a></li><li><a href="ShapeGenerator.html">ShapeGenerator</a></li><li><a href="Utils.html">Utils</a></li><li><a href="Vector.html">Vector</a></li><li><a href="Viewport.html">Viewport</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sat Feb 29 2020 17:50:34 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
