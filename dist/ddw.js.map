{"version":3,"sources":["webpack://ddw/webpack/bootstrap","webpack://ddw/./index.js","webpack://ddw/./src/class/Body.js","webpack://ddw/./src/class/Collision.js","webpack://ddw/./src/class/Geometry.js","webpack://ddw/./src/class/GlobalInteraction.js","webpack://ddw/./src/class/Gravity.js","webpack://ddw/./src/class/Model.js","webpack://ddw/./src/class/ModelDrawer.js","webpack://ddw/./src/class/Physics.js","webpack://ddw/./src/class/PolygonGenerator.js","webpack://ddw/./src/class/Scene.js","webpack://ddw/./src/class/ScenePlayer.js","webpack://ddw/./src/class/SpatialInteraction.js","webpack://ddw/./src/class/SpatialPartitioner.js","webpack://ddw/./src/class/Utils.js","webpack://ddw/./src/class/Vector.js","webpack://ddw/./src/class/Viewport.js"],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA,cAAc,mBAAO,CAAC,+CAAmB;AACzC,yBAAyB,mBAAO,CAAC,qEAA8B;AAC/D,cAAc,mBAAO,CAAC,+CAAmB;AACzC,oBAAoB,mBAAO,CAAC,2DAAyB;AACrD,cAAc,mBAAO,CAAC,+CAAmB;AACzC,oBAAoB,mBAAO,CAAC,2DAAyB;AACrD,aAAa,mBAAO,CAAC,6CAAkB;AACvC,eAAe,mBAAO,CAAC,iDAAoB;AAC3C,iBAAiB,mBAAO,CAAC,qDAAsB;AAC/C,2BAA2B,mBAAO,CAAC,yEAAgC;AACnE,0BAA0B,mBAAO,CAAC,uEAA+B;AACjE,2BAA2B,mBAAO,CAAC,yEAAgC;AACnE,kBAAkB,mBAAO,CAAC,uDAAuB;AACjD,gBAAgB,mBAAO,CAAC,mDAAqB;AAC7C,gBAAgB,mBAAO,CAAC,mDAAqB;AAC7C,iBAAiB,mBAAO,CAAC,qDAAsB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClCA,eAAe,mBAAO,CAAC,uCAAU;AACjC,cAAc,mBAAO,CAAC,qCAAS;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C,8BAA8B,kDAAkD;AAChF,8BAA8B,+BAA+B;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC1GA,2BAA2B,mBAAO,CAAC,+DAAsB;AACzD,gBAAgB,mBAAO,CAAC,yCAAW;AACnC,iBAAiB,mBAAO,CAAC,2CAAY;;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC5BA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC1CA;;AAEA,SAAS;;AAET;AACA,oCAAoC,OAAO;AAC3C;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACjBA,0BAA0B,mBAAO,CAAC,6DAAqB;AACvD,gBAAgB,mBAAO,CAAC,yCAAW;;AAEnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACrBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA,oBAAoB,4BAA4B;AAChD,oBAAoB,2BAA2B;AAC/C,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA,oBAAoB,+BAA+B;AACnD,oBAAoB,2BAA2B;AAC/C,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACzGA,eAAe,mBAAO,CAAC,uCAAU;;AAEjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,QAAQ;;AAEjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AClHA,eAAe,mBAAO,CAAC,uCAAU;;AAEjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AClFA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACnBA,cAAc,mBAAO,CAAC,qCAAS;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC,OAAO;AAChD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;;AAEA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;;AAEA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;;AAEA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,gDAAgD,sCAAsC;AACtF,6CAA6C,8CAA8C;AAC3F;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC1JA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACxDA,2BAA2B,mBAAO,CAAC,+DAAsB;;AAEzD;;AAEA,SAAS;;AAET;AACA;;AAEA;AACA,wCAAwC,OAAO;AAC/C;;AAEA;AACA;;AAEA;AACA,iDAAiD,OAAO;AACxD;;AAEA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,OAAO;AACrD;AACA,6DAA6D,OAAO;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACzCA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC1FA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,EAAE,UAAU,EAAE,UAAU,EAAE;AACvD;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA,4CAA4C,4CAA4C;AACxF;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;AClEA;;AAEA;AACA;AACA,yBAAyB,8IAA8I;AACvK;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA,uBAAuB,uDAAuD;AAC9E;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA,uBAAuB,uDAAuD;AAC9E;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA,uBAAuB,uCAAuC;AAC9D;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA,uBAAuB,uCAAuC;AAC9D;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA,mKAAmK,MAAM,gCAAgC,MAAM,kCAAkC,MAAM;AACvP;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0HAA0H,MAAM,sBAAsB,MAAM,0BAA0B,MAAM;AAC5L;AACA,YAAY,OAAO;AACnB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AChYA,aAAa,mBAAO,CAAC,mCAAQ;AAC7B,cAAc,mBAAO,CAAC,qCAAS;AAC/B,cAAc,mBAAO,CAAC,qCAAS;AAC/B,iBAAiB,mBAAO,CAAC,2CAAY;;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,2BAA2B;;AAE5C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;;AAEA","file":"ddw.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n","const Utils = require(\"./src/class/Utils\");\nconst PolygonGenerator = require(\"./src/class/PolygonGenerator\");\nconst Model = require(\"./src/class/Model\");\nconst ModelDrawer = require(\"./src/class/ModelDrawer\");\nconst Scene = require(\"./src/class/Scene\");\nconst ScenePlayer = require(\"./src/class/ScenePlayer\");\nconst Body = require(\"./src/class/Body\");\nconst Vector = require(\"./src/class/Vector\");\nconst Viewport = require(\"./src/class/Viewport\");\nconst SpatialPartitioner = require(\"./src/class/SpatialPartitioner\");\nconst GlobalInteraction = require(\"./src/class/GlobalInteraction\");\nconst SpatialInteraction = require(\"./src/class/SpatialInteraction\");\nconst Collision = require(\"./src/class/Collision\");\nconst Gravity = require(\"./src/class/Gravity\");\nconst Physics = require(\"./src/class/Physics\");\nconst Geometry = require(\"./src/class/Geometry\");\n\nmodule.exports = {\n\tUtils,\n\tPolygonGenerator,\n\tModel,\n\tModelDrawer,\n\tScene,\n\tBody,\n\tScenePlayer,\n\tVector,\n\tViewport,\n\tSpatialPartitioner,\n\tSpatialInteraction,\n\tGlobalInteraction,\n\tCollision,\n\tGravity,\n\tPhysics,\n\tGeometry\n}\n","const Vector = require('./Vector');\nconst Utils = require('./Utils');\n\nclass Body {\n\n\tconstructor(settings) {\n\t\tsettings = settings || {};\n\t\tsettings.x = settings.x || 0;\n\t\tsettings.y = settings.y || 0;\n    settings.speed = settings.speed || 0;\n\t\tsettings.heading = settings.heading || 0;\n\n    this.angleAcceleration = 0;\n    this.angleVelocity = settings.angleVelocity || 0;\n\t\tthis.angle = settings.angle || 0;\n\t\tthis.acceleration = new Vector({ x: 0, y: 0 });\n\t\tthis.velocity = new Vector({ length: settings.speed, angle: settings.heading });\n\t\tthis.location = new Vector({ x: settings.x, y: settings.y });\n\t\tthis.mass = settings.mass || 1;\n\t\tthis.scale = settings.scale || 1;\n\t\tthis.uuid = Utils.uniqueID();\n    this.model = settings.model;\n    this.world = this.getWorldTransform();\n\t}\n\n  getAngle() {\n    return this.angle;\n  }\n\n  getScale() {\n    return this.scale;\n  }\n\n\tgetHeading() {\n\t\treturn this.velocity.getAngle();\n\t}\n\n\tsetHeading(angle) {\n\t\tthis.velocity.setAngle(angle);\n\t}\n\n\tgetSpeed() {\n\t\treturn this.velocity.getLength();\n\t}\n\n\tsetSpeed(speed) {\n\t\tthis.velocity.setLength(speed);\n\t}\n\n  getLocation() {\n    return this.location;\n  }\n\n\tgetBoundingRect() {\n\t\treturn [\n\t\t\t[this.world.bounds.xMin, this.world.bounds.yMin],\n\t\t\t[this.world.bounds.xMin, this.world.bounds.yMax],\n\t\t\t[this.world.bounds.xMax, this.world.bounds.yMax],\n\t\t\t[this.world.bounds.xMax, this.world.bounds.yMin]\n\t\t];\n\t}\n\n\tupdate() {\n    // Update Position\n\t\tthis.velocity.addTo(this.acceleration);\n\t\tthis.location.addTo(this.velocity);\n\t\tthis.acceleration.multiplyBy(0);\n    // Update angle\n    this.angleVelocity += this.angleAcceleration;\n    this.angle += this.angleVelocity;\n    this.angleAcceleration = 0;\n    // World transformation\n    this.world = this.getWorldTransform();\n\t}\n\n  getWorldTransform() {\n    return this.model.transform(this.angle, this.scale, [this.location.getX(), this.location.getY()]);\n  }\n\n\tgetRadius() {\n\t\treturn this.world.radius;\n\t}\n\n\tsetPosition(position) {\n\t\tthis.location = position;\n\t}\n\n\tapplyForce(force) {\n\t\tlet f = force.divide(this.mass);\n\t\tthis.acceleration.addTo(f);\n\t}\n\n\tapplyNetForce(force) {\n\t\tthis.acceleration.addTo(force);\n\t}\n\n\tresetVelocity() {\n\t\tthis.velocity.multiplyBy(0);\n\t}\n\n\tdistanceTo(target) {\n\t\treturn target.location.substract(this.location).getLength() - this.getRadius() - target.getRadius();\n\t}\n\n}\n\nmodule.exports = Body;\n","const SpatialInteraction = require(\"./SpatialInteraction\");\nconst Physics = require(\"./Physics\");\nconst Geometry = require(\"./Geometry\");\n\nclass Collision extends SpatialInteraction {\n\n  constructor(settings) {\n    super(settings);\n    this.physics = Physics;\n    this.geometry = Geometry;\n    this.intersector = settings.intersector;\n    this.resolver = settings.resolver;\n    this.collision = this.collision.bind(this);\n  }\n\n  run() {\n    this.resolve(this.collision);\n  }\n\n  collision(bodyA, bodyB) {\n    const intersection = this.geometry.circleCircleIntersection(bodyA.world, bodyB.world);\n    if (intersection) {\n      this.physics.elasticCollision(bodyA, bodyB, intersection);\n    }\n  }\n\n}\n\nmodule.exports = Collision;\n","class Geometry {\n\n  rectangleRectangleIntersection(r1, r2) {\n    return this.rangeIntersect(r1.bounds.xMin, r1.bounds.xMin + r1.width, r2.bounds.xMin, r2.bounds.xMin + r2.width) &&\n      this.rangeIntersect(r1.bounds.yMin, r1.bounds.yMin + r1.height, r2.bounds.yMin, r2.bounds.yMin + r2.height);\n  }\n\n\tcircleRectangleIntersection(c, r) {\n\t\tconst distX = Math.abs(c.center[0] - r.bounds.xMin - r.width / 2);\n\t\tconst distY = Math.abs(c.center[1] - r.bounds.yMin - r.height / 2);\n\t\t// Out of range\n\t\tif (distX > (r.width / 2 + c.radius) || distY > (r.height / 2 + c.radius)) {\n\t\t\treturn false;\n\t\t}\n\t\t// In range\n\t\tif (distX <= (r.width / 2) || distY <= (r.height / 2)) {\n\t\t\treturn true;\n\t\t}\n\t\t// Rectangle corners\n\t\tconst dx = distX - r.width / 2;\n\t\tconst dy = distY - r.height / 2;\n\t\treturn (dx * dx + dy * dy <= (c.radius * c.radius));\n\t}\n\n\tcircleCircleIntersection(c1, c2) {\n\t\tconst xDist = c1.center[0] - c2.center[0];\n\t\tconst yDist = c1.center[1] - c2.center[1];\n\t\tconst distSquared = (xDist * xDist) + (yDist * yDist);\n\t\tconst radiusSquared = (c1.radius + c2.radius) * (c1.radius + c2.radius);\n\t\tif (distSquared < radiusSquared) {\n\t\t\treturn { x: xDist, y: yDist, dist_squared: distSquared };\n\t\t}\n\t\treturn false;\n\t}\n\n  rangeIntersect(min0, max0, min1, max1) {\n    return  Math.max(min0, max0) >= Math.min(min1, max1) &&\n      Math.min(min0, max0) <= Math.max(min1, max1);\n  }\n\n}\n\nmodule.exports = new Geometry();\n","class GloalInteraction {\n\n  run() { }\n\n  resolve(bodies, cb) {\n    for (let i=0, len=bodies.length; i<len; i++) {\n      const bodyA = bodies[i];\n      for (let j=0, len=bodies.length; j<len; j++) {\n        const bodyB = bodies[j];\n        if (bodyA.uuid === bodyB.uuid) continue;\n        cb(bodyA, bodyB);\n      }\n    }\n  }\n\n}\n\nmodule.exports = GloalInteraction;\n","const GlobalInteraction = require(\"./GlobalInteraction\");\nconst Physics = require(\"./Physics\");\n\nclass Gravity extends GlobalInteraction {\n\n  constructor(settings) {\n    super(settings);\n    this.physics = Physics;\n    this.gravitate = this.gravitate.bind(this);\n  }\n\n  run(bodies) {\n    this.resolve(bodies, this.gravitate);\n  }\n\n  gravitate(bodyA, bodyB) {\n    this.physics.gravity(bodyA, bodyB);\n  }\n\n}\n\nmodule.exports = Gravity;\n","class Model {\n\n\tconstructor(settings) {\n    this.points = settings.points || [];\n\t\tthis.strokeColor = settings.strokeColor || null;\n    this.fillColor = settings.fillColor || null;\n    this.fillGradient = settings.fillGradient || null;\n\t\tthis.filter = settings.filter || null;\n\t\tthis.bounds = this.getBounds();\n\t\tthis.center = this.getCenter();\n\t\tthis.width = this.bounds.xMax - this.bounds.xMin;\n\t\tthis.height = this.bounds.yMax - this.bounds.yMin;\n\t\tthis.radius = Math.max(this.width, this.height) / 2;\n\t\tthis.children = settings.children || [];\n\t}\n\n  getPoints() {\n    return this.points;\n  }\n\n\tgetBounds() {\n\t\tconst xs = [];\n\t\tconst ys = [];\n\t\tfor (let i=0,len=this.points.length; i<len; i++) {\n\t\t\tconst point = this.points[i];\n\t\t\txs.push(point[0]);\n\t\t\tys.push(point[1]);\n\t\t}\n\t\treturn {\n\t\t\txMin: Math.min.apply(null, xs),\n\t\t\txMax: Math.max.apply(null, xs),\n\t\t\tyMin: Math.min.apply(null, ys),\n\t\t\tyMax: Math.max.apply(null, ys)\n\t\t};\n\t}\n\n\tgetCenter() {\n\t\treturn [\n\t\t\t(this.bounds.xMin + this.bounds.xMax) / 2,\n\t\t\t(this.bounds.yMin + this.bounds.yMax) / 2\n\t\t];\n\t}\n\n  transform(r, s, t) {\n\t\tt = t || [0, 0];\n    const transformed = [];\n\t\tfor (let j=0,len=this.points.length; j<len; j++) {\n      let p = this.points[j];\n\t\t\tif (r !== null) { p = this.rotatePoint(p, r); }\n\t\t\tif (s !== null) { p = this.scalePoint(p, s); }\n\t\t\tif (t !== null) { p = this.translatePoint(p, t); }\n\t\t\ttransformed.push(p);\n\t\t}\n    return new this.constructor({\n      points: transformed,\n      strokeColor: this.strokeColor,\n      fillColor: this.fillColor,\n\t\t\tfillGradient: this.fillGradient,//this.fillGradient ? this.transformGradient(this.fillGradient, r, s, t):null,\n\t\t\tfilter: this.filter,\n\t\t\tchildren: this.children.map(c => c.transform(r, s, t))\n    });\n\t}\n\n\ttransformInversion(t, s, r) {\n    const transformed = [];\n\t\tfor (let j=0,len=this.points.length; j<len; j++) {\n      let p = this.points[j];\n\t\t\tif (t !== null) { p = this.translatePoint(p, t); }\n\t\t\tif (s !== null) { p = this.scalePoint(p, s); }\n\t\t\tif (r !== null) { p = this.rotatePoint(p, r); }\n\t\t\ttransformed.push(p);\n\t\t}\n    return new this.constructor({\n      points: transformed,\n      strokeColor: this.strokeColor,\n      fillColor: this.fillColor,\n\t\t\tfillGradient: this.fillGradient,\n\t\t\tfilter: this.filter,\n\t\t\tchildren: this.children.map(c => c.transformInversion(t, s, r))\n    });\n\t}\n\n  rotatePoint(point, angle) {\n    return [\n      point[0] * Math.cos(angle) - point[1] * Math.sin(angle),\n      point[0] * Math.sin(angle) + point[1] * Math.cos(angle)\n    ];\n  }\n\n  scalePoint(point, scale) {\n    return [\n      point[0] * scale,\n      point[1] * scale\n    ]\n  }\n\n  translatePoint(point, position) {\n    return [\n      point[0] + position[0],\n      point[1] + position[1]\n    ]\n  }\n\n}\n\nmodule.exports = Model;\n","const Vector = require(\"./Vector\");\n\nclass ModelDrawer {\n\n\tdrawModel(model, ctx) {\n    const points = model.getPoints();\n\n\t\tif (model.filter) {\n\t\t\tctx.save()\n\t\t\tctx.filter = model.filter;\n\t\t}\n\n\t\tctx.beginPath();\n\t\tfor (let i = 0, len=points.length; i<len; i++) {\n\t\t\tconst a = points[i];\n\t\t\tconst b = i === len - 1 ? points[0] : points[i + 1];\n\t\t\tif (i === 0) {\n\t\t\t\tctx.moveTo(a[0], a[1]);\n\t\t\t}\n\t\t\tctx.lineTo(b[0], b[1]);\n\t\t}\n\t\tctx.closePath();\n\n\t\tif (model.strokeColor) {\n\t\t\tctx.strokeStyle = model.strokeColor;\n\t\t\tctx.stroke();\n\t\t}\n\n\t\tif (model.fillColor) {\n\t\t\tctx.fillStyle = model.fillColor;\n\t\t\tctx.fill();\n\t\t}\n\n\t\tif (model.fillGradient) {\n\t\t\tctx.fillStyle = this.createRadialGradient(model, ctx);\n\t\t\tctx.fill();\n\t\t}\n\n\t\tif (model.filter) {\n\t\t\tctx.restore();\n\t\t}\n\n\t\tmodel.children.map(m => this.drawModel(m, ctx));\n\t}\n\n\tdrawBoundingRectangle(model, ctx) {\n\t\tctx.beginPath();\n    ctx.strokeStyle = \"yellow\";\n    ctx.strokeRect(model.bounds.xMin, model.bounds.yMin, model.width, model.height);\n    ctx.closePath();\n\t}\n\n\tdrawBoundingCircle(model, ctx) {\n\t\tctx.beginPath();\n    ctx.strokeStyle = \"yellow\";\n    ctx.arc(model.center[0], model.center[1], model.radius, 0, 2 * Math.PI);\n\t\tctx.stroke();\n\t\tctx.closePath();\n\t}\n\n\tdrawInnerShadow(model, lightSource, ctx, shadowScale, shadowDisplacement, shadowSpread) {\n\t\tif (model.radius < 1) { return; }\n\n\t\tshadowScale = shadowScale || 6;\n\t\tshadowDisplacement = shadowDisplacement || 0.92;\n\t\tshadowSpread = shadowSpread || 0.94;\n\n\t  const shadowModelRadius = model.radius * shadowScale;\n\t  const shadowVector = new Vector({\n\t    x: model.center[0] - lightSource.center[0],\n\t    y: model.center[1] - lightSource.center[1]\n\t  });\n\n\t  shadowVector.normalize();\n\t  shadowVector.multiplyBy(shadowModelRadius * shadowDisplacement);\n\t\tshadowVector.x += model.center[0];\n\t  shadowVector.y += model.center[1];\n\n\t  ctx.save();\n\n\t  // Create clipping path\n\t  let region = new Path2D();\n\t  region.arc(model.center[0], model.center[1], model.radius + 1, 0, Math.PI*2, true);\n\t  ctx.clip(region);\n\n\t  // Shadow model\n\t  const gradient = ctx.createRadialGradient(shadowVector.getX(), shadowVector.getY(), shadowModelRadius * shadowSpread, shadowVector.getX(), shadowVector.getY(), shadowModelRadius);\n\t  gradient.addColorStop(0, \"rgba(0, 0, 0, 0.9)\");\n\t  gradient.addColorStop(1, \"rgba(0, 0, 0, 0.001)\");\n\n\t  ctx.beginPath();\n\t  ctx.fillStyle = gradient;\n\t  ctx.arc(shadowVector.getX(), shadowVector.getY(), shadowModelRadius, 0, Math.PI * 2, true);\n\t  ctx.fill();\n\t  ctx.closePath();\n\n\t  ctx.restore();\n\t}\n\n\tcreateRadialGradient(model, ctx) {\n\t\tconst gradient = ctx.createRadialGradient(model.center[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.center[1],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.center[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.center[1],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.radius);\n\n\t\tgradient.addColorStop(0, model.fillGradient.stop1);\n\t\tgradient.addColorStop(1, model.fillGradient.stop2);\n\t\treturn gradient;\n\t}\n\n}\n\nmodule.exports = ModelDrawer;\n","const Vector = require('./Vector');\n\nclass Physics {\n\n  constructor(settings) {\n    settings = settings || {};\n    this.G = settings.G || 9.8;\n  }\n\n  gravity(source, target) {\n\t\tconst dir = target.location.substract(source.location);\n\t\tconst distance = dir.getLength();\n\t\tconst minDistance = target.getRadius() + source.getRadius();\n\t\tif (minDistance > distance) {\n\t\t\treturn;\n\t\t}\n\t\tconst force = this.G * (source.mass * target.mass / (distance * distance));\n\t\tdir.normalize();\n\t\tdir.multiplyBy(force);\n\t\tsource.applyForce(dir);\n\t}\n\n  elasticCollision(source, target, intersection) {\n\n\t\t// Displacement vector (difference in velocity)\n\t\tconst xVelocity = target.velocity.getX() - source.velocity.getX();\n\t\tconst yVelocity = target.velocity.getY() - source.velocity.getY();\n\n\t\t// If both bodies are moving away from each other, discard collision\n\t\tconst dotProduct = (intersection.x * xVelocity) + (intersection.y * yVelocity);\n\n\t\t// Collision handling\n\t\tif (dotProduct > 0) {\n\n\t\t\t// The resulting force from the collision (angle difference + velocity difference)\n\t\t\tconst collisionScale = dotProduct / intersection.dist_squared;\n\n\t\t\t// Collision Vector:\n\t\t\tconst collision = {\n\t\t\t\tx: intersection.x * collisionScale,\n\t\t\t\ty: intersection.y * collisionScale\n\t\t\t};\n\n\t\t\t// Restitution aproximation\n\t\t\tconst totalDensity = source.density + target.density;\n\t\t\tconst r1 = (source.density / totalDensity) / 2;\n\t\t\tconst r2 = (target.density / totalDensity) / 2;\n\n\n\t\t\t// 2D Elastic collision\n\t\t\tconst combinedMass = source.mass + target.mass;\n\t\t\tconst collisionWeight1 = (2 * target.mass / combinedMass) * 0.1;\n\t\t\tconst collisionWeight2 = (2 * source.mass / combinedMass) * 0.25;\n\n\t\t\tconst collisionResult1 = new Vector({\n\t\t\t\tx: collisionWeight1 * collision.x,\n\t\t\t\ty: collisionWeight1 * collision.y\n\t\t\t});\n\n\t\t\tconst collisionResult2 = new Vector({\n\t\t\t\tx: collisionWeight2 * collision.x,\n\t\t\t\ty: collisionWeight2 * collision.y\n\t\t\t})\n\t\t\t.multiply(-1);\n\n\t\t\tsource.applyNetForce(collisionResult1);\n\t\t\ttarget.applyNetForce(collisionResult2);\n\t\t}\n\t}\n\n  orbitDistanceBySpeed(body, target, speed) {\n    return (body.mass * target.mass) / speed;\n  }\n\n  orbitSpeedByDistance(body, target, G) {\n    G = G || 9.8;\n    const distance = body.distanceTo(target);\n    return Math.sqrt((G * target.mass) / distance);\n  }\n\n}\n\nmodule.exports = new Physics();\n","class PolygonGenerator {\n\n  circle(settings) {\n    const divs = settings.divs || 32;\n    const radius = settings.radius || 1;\n    const angleFraction = (Math.PI * 2) / settings.divs;\n    const points = [];\n    for (let i=0; i<divs; i++) {\n      const point = [\n        Math.cos(angleFraction * i + 1) * radius,\n        Math.sin(angleFraction * i + 1) * radius,\n      ];\n      points.push(point);\n    }\n    return points;\n  }\n\n}\n\nmodule.exports = new PolygonGenerator();\n","const Model = require(\"./Model\");\n\nclass Scene {\n\n\tconstructor(settings) {\n\t\tsettings = settings || {};\n    this.bodies = settings.bodies || [];\n\t\tthis.width = settings.width || 800;\n\t\tthis.height = settings.height || 600;\n\t\tthis.lightSource = settings.lightSource || null;\n    this.viewport = settings.viewport;\n    this.drawer = settings.drawer;\n\t\tthis.ctx = settings.ctx;\n\t\tthis.spatialInteractions = settings.spatialInteractions || [];\n\t\tthis.globalInteractions = settings.globalInteractions || [];\n    this.playerFps = 0;\n    this.debug = settings.debug || false;\n\t\tthis.init();\n\t}\n\n\tinit() {\n\t\tthis.boundries = [{\n\t\t\tx: -this.width / 2,\n\t\t\ty: -this.height / 2\n\t\t}, {\n\t\t\tx: this.width / 2,\n\t\t\ty: -this.height / 2\n\t\t}, {\n\t\t\tx: this.width / 2,\n\t\t\ty: this.height / 2\n\t\t}, {\n\t\t\tx: -this.width / 2,\n\t\t\ty: this.height / 2\n\t\t}];\n\t\tthis.ctx.translate(this.width / 2, this.height / 2);\n\t\tthis.run = this.run.bind(this);\n\t}\n\n\trun() {\n    this.ctx.clearRect(this.boundries[0].x, this.boundries[0].y, this.width, this.height);\n\n    this.update();\n    this.runSpatialInteractions();\n\t\tthis.runGlobalInteractions();\n\n\t\tif (this.debug) this.debugDraw();\n    this.draw();\n  }\n\n  update() {\n    this.viewport.update();\n\t\tthis.resetSpatialInteractions();\n    for (let i=0, len=this.bodies.length; i<len; i++) {\n      const body = this.bodies[i];\n      body.update();\n      this.spatialRegister(body);\n    }\n\t}\n\n\tdraw() {\n\t\tconst lightSourceViewModel = this.lightSource ? this.viewport.getRelativeView(this.lightSource):null;\n\n    for (let i=0, len=this.bodies.length; i<len; i++) {\n      const body = this.bodies[i];\n      if (this.viewport.intersects(body)) {\n\n\t\t\t\tconst bodyViewModel = this.viewport.getRelativeView(body);\n\n\t\t\t\tthis.drawer.drawModel(bodyViewModel, this.ctx);\n\n\t\t\t\tif (body.drawShadow && this.lightSource && this.lightSource.uuid !== body.uuid) {\n\t\t\t\t\tthis.drawer.drawInnerShadow(bodyViewModel, lightSourceViewModel, this.ctx);\n\t\t\t\t}\n\n      }\n    }\n\n\t\t// Framerate\n    this.printText(\"FPS: \"+ this.playerFps);\n\t}\n\n\tdebugDraw() {\n    // Display Spatial Partitioning grids\n\t\tthis.spatialInteractions.forEach(spi => {\n\t\t\tif (spi.debug) this.drawSpatialGrid(spi);\n\t\t});\n  }\n\n\trunGlobalInteractions() {\n\t\tfor (let i=0,len=this.globalInteractions.length; i<len; i++) {\n\t\t\tthis.globalInteractions[i].run(this.bodies);\n\t\t}\n\t}\n\n\trunSpatialInteractions() {\n\t\tfor (let i=0,len=this.spatialInteractions.length; i<len; i++) {\n\t\t\tthis.spatialInteractions[i].run();\n\t\t}\n\t}\n\n\tresetSpatialInteractions() {\n\t\tfor (let i=0,len=this.spatialInteractions.length; i<len; i++) {\n\t\t\tthis.spatialInteractions[i].resetGrid();\n\t\t}\n\t}\n\n\tspatialRegister(body) {\n\t\tfor (let i=0,len=this.spatialInteractions.length; i<len; i++) {\n\t\t\tthis.spatialInteractions[i].registerBody(body);\n\t\t}\n\t}\n\n\tdrawSpatialGrid(spi) {\n\t\tconst cells = spi.getCells();\n    const cellSize = spi.cellSize;\n\n    cells.forEach(c => {\n\t\t\tconst neighborRange = cellSize * spi.neighborRange;\n      const cellModel = new Model({\n        points: [\n          [c.x * cellSize, c.y * cellSize],\n          [c.x * cellSize + cellSize, c.y * cellSize],\n          [c.x * cellSize + cellSize, c.y * cellSize + cellSize],\n          [c.x * cellSize, c.y * cellSize + cellSize],\n        ],\n        strokeColor: \"rgba(0, 255, 0, 0.6)\"\n      });\n\t\t\tconst neighborhoodModel = new Model({\n        points: [\n          [c.x * cellSize - neighborRange, c.y * cellSize - neighborRange],\n          [c.x * cellSize + cellSize + neighborRange, c.y * cellSize - neighborRange],\n          [c.x * cellSize + cellSize + neighborRange, c.y * cellSize + cellSize + neighborRange],\n          [c.x * cellSize - neighborRange, c.y * cellSize + cellSize + neighborRange]\n        ],\n        strokeColor: \"rgba(55, 20, 0, 0.6)\"\n      });\n      const v1 = this.viewport.getRelativeView({ getScale: () => 1, world: cellModel });\n\t\t\tconst v2 = this.viewport.getRelativeView({ getScale: () => 1, world: neighborhoodModel });\n\t\t\tthis.drawer.drawModel(v1, this.ctx);\n\t\t\tthis.drawer.drawModel(v2, this.ctx);\n    });\n\n\t}\n\n  printText(text, x, y) {\n    x = x || this.boundries[0].x;\n    y = y || this.boundries[0].y + 20;\n    this.ctx.font = \"16px Arial\";\n    this.ctx.fillStyle = \"red\";\n    this.ctx.fillText(text, x, y);\n  }\n\n}\n\nmodule.exports = Scene;\n","class ScenePlayer {\n\n\tconstructor(settings) {\n\t\tsettings = settings || {};\n\t\tthis.scene = settings.scene;\n\t\tthis.fps = settings.fps || 60;\n\t\tthis.playing = false;\n\t\tthis.requestId = null;\n\t\tthis.then = 0;\n\t\tthis.startTime = 0;\n\t\tthis.fpsInterval = 1000 / this.fps;\n\t\tthis.frameCount = 0;\n\t\tthis.framerate = 0;\n\t\tthis.forward = this.forward.bind(this);\n\t}\n\n\tgetFps() {\n\t\treturn this.framerate;\n\t}\n\n\tplay() {\n\t\tthis.playing = true;\n\t\tthis.reset();\n\t\tthis.forward();\n\t}\n\n\tforward(newtime) {\n\t\tthis.requestId = window.requestAnimationFrame(this.forward);\n    const elapsed = newtime - this.then;\n    if (elapsed > this.fpsInterval) {\n        this.then = newtime - (elapsed % this.fpsInterval);\n\t\t\t\t// Draw scene\n\t\t\t\tthis.scene.run();\n\t\t\t\t// Calculate framerate\n        const sinceStart = newtime - this.startTime;\n        this.framerate = Math.round(1000 / (sinceStart / ++this.frameCount) * 100) / 100;\n\t\t\t\t// Pass framerate to scene\n\t\t\t\tthis.scene.playerFps = this.framerate;\n\t\t}\n\t}\n\n\tstop() {\n\t\tif (!this.playing) { return false; }\n\t\twindow.cancelAnimationFrame(this.requestId);\n\t\tthis.playing = false;\n\t\tthis.requestId = null;\n\t}\n\n\treset() {\n\t\tthis.then = performance.now();\n    this.startTime = this.then;\n\t\tthis.frameCount = 0;\n\t}\n\n}\n\nmodule.exports = ScenePlayer;\n","const SpatialPartitioner = require(\"./SpatialPartitioner\");\n\nclass SpatialInteraction extends SpatialPartitioner {\n\n  run() { }\n\n  resolve(localResolver, neighborResolver) {\n    neighborResolver = neighborResolver || localResolver;\n\n    // Iterate cells\n    for (let i=0, len=this.cells.length; i<len; i++) {\n      const currentCell = this.cells[i];\n\n      // Find neighbor cells\n      const neighborCells = this.getNeighborCells(currentCell);\n\n      // Iterate local bodies\n      for (let j=0,len=currentCell.bodies.length; j<len; j++) {\n        const currentBody = currentCell.bodies[j];\n\n        // Resolve local-local pairs\n        for (let k=0,len=currentCell.bodies.length; k<len; k++) {\n          const localBody = currentCell.bodies[k];\n          if (currentBody.uuid === localBody.uuid) continue;\n          localResolver(currentBody, localBody);\n        }\n\n        // Resolve local-neighbor pairs\n        for (let k=0,len=neighborCells.length; k<len; k++) {\n          const currentNeighborCell = neighborCells[k];\n          for (let l=0,len=currentNeighborCell.bodies.length; l<len; l++) {\n            const neighborBody = currentNeighborCell.bodies[l];\n            neighborResolver(currentBody, neighborBody);\n          }\n        }\n      }\n    }\n\t}\n\n}\n\nmodule.exports = SpatialInteraction;\n","class SpatialPartitioner {\n\n\tconstructor(settings) {\n\t\tsettings = settings || {};\n\t\tthis.cellSize = settings.cellSize || 128;\n    this.neighborRange = settings.neighborRange || 1;\n\t\tthis.cells = [];\n    this.cellIndex = {};\n\t\tthis.debug = settings.debug || false;\n\t}\n\n  run() { }\n\n\tgetCell(cellId) {\n\t\tif (this.cellIndex[cellId]) {\n      return this.cellIndex[cellId];\n    }\n\t}\n\n\tgetCells() {\n\t\treturn this.cells;\n\t}\n\n  getNeighborCells(cell) {\n    const neighborCells = [];\n    const neighborIds = this.getNeighborCellIds(cell.x, cell.y);\n    for (let i=0,len=neighborIds.length; i<len; i++) {\n      const id = neighborIds[i];\n      const neighbor = this.getCell(id);\n      if (neighbor) {\n        neighborCells.push(neighbor);\n      }\n    }\n    return neighborCells;\n  }\n\n  getNeighborCellIds(x, y) {\n    return [\n      [x - 1, y - 1].join(\"_\"),\n      [x, y - 1].join(\"_\"),\n      [x + 1, y - 1].join(\"_\"),\n      [x + 1, y].join(\"_\"),\n      [x + 1, y + 1].join(\"_\"),\n      [x, y + 1].join(\"_\"),\n      [x - 1, y + 1].join(\"_\"),\n      [x - 1, y].join(\"_\")\n    ];\n  }\n\n\taddCell(cellData) {\n    const cell = {\n\t\t\t...cellData,\n\t\t\tbodies: []\n\t\t};\n\t\tthis.cells.push(cell);\n    this.cellIndex[cellData.id] = cell;\n\t\treturn cell;\n\t}\n\n\tresetGrid() {\n\t\tthis.cells = [];\n    this.cellIndex = {};\n\t}\n\n  registerBody(body, center) {\n    const point = body.world.getCenter();\n    const cellData = this.pointPosition(point);\n\n    // Create new cell if required\n    let cell = this.getCell(cellData.id);\n    if (!cell) {\n      cell = this.addCell(cellData);\n    }\n\n    // Add body in cell's collection\n    cell.bodies.push(body);\n  }\n\n\tpointPosition(point) {\n\t\tconst xComponent = Math.floor(point[0] / this.cellSize);\n\t\tconst yComponent = Math.floor(point[1] / this.cellSize);\n    return {\n      x: xComponent,\n      y: yComponent,\n      id: [xComponent, yComponent].join(\"_\")\n    }\n\t}\n\n}\n\nmodule.exports = SpatialPartitioner;\n","class Utils {\n\n  /**\n  * Generates a unique id.\n  * @method\n  * @returns {String} - A unique id.\n  */\n  uniqueID() {\n    function s4() {\n      return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n    }\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n  }\n\n  /**\n  * Returns a random value between the defined range.\n  * @method\n  * @param {Float} min - Minimum value of the range.\n  * @param {Float} max - Maximum value of the range.\n  * @returns {Float} - A random value between min and max.\n  */\n  randomRange(min, max) {\n    return min + Math.random() * (max - min);\n  }\n\n  mapRange(value, low1, high1, low2, high2) {\n    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);\n  }\n\n  /**\n  * Generates a random angle between -pi and +pi.\n  * @method\n  * @returns {Float} - An angle in radians.\n  */\n  randomAngle() {\n    return this.randomRange(-Math.PI, Math.PI);\n  }\n\n  componentToHex(c) {\n    var hex = c.toString(16);\n    return hex.length == 1 ? \"0\" + hex : hex;\n  }\n\n  rgbToHex(r, g, b) {\n    return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n  }\n\n  hexToRgb(hex) {\n   var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n   return result ? {\n     r: parseInt(result[1], 16),\n     g: parseInt(result[2], 16),\n     b: parseInt(result[3], 16)\n   } : null;\n }\n\n randomColor() {\n   return \"#000000\".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});\n }\n\n}\n\nconst instance = new Utils();\n\nmodule.exports = instance;\n","class Vector {\n\n  /**\n  * A 2D vector class that provides a wide range of vector operations.\n  * @summary View file: {@link https://github.com/GorillaBus/ddw/blob/master/src/class/BodyManager.js https://github.com/GorillaBus/ddw/blob/master/src/class/Shape.js}.\n  * @constructor\n  * @param {Object} settings - Json object with construction options.\n  * @param {Float} [settings.x=0] - Initial X vector component.\n  * @param {Float} [settings.y=0] - Initial Y vector component.\n  * @param {Float} [settings.length=0] - Initial vector magnitude or length.\n  * @param {Float} [settings.angle=0] - Initial vector angle in radians.\n  */\n  constructor(settings) {\n    settings = settings || {};\n    settings.x = settings.x || 0;\n    settings.y = settings.y || 0;\n    settings.length = settings.length || 0;\n    settings.angle = settings.angle || 0;\n    this.x = settings.x;\n    this.y = settings.y;\n    if (settings.length) {\n      this.setLength(settings.length);\n    }\n    if (settings.angle) {\n      this.setAngle(settings.angle);\n    }\n  }\n\n  /**\n  * Sets the X component of the vector.\n  * @method\n  * @param {Float} magnitude - Vector magnitude over the X axis.\n  */\n  setX(magnitude) {\n    this.x = magnitude;\n  }\n\n  /**\n  * Gets the X component of the vector.\n  * @method\n  * @returns {Float} Vector magnitude over the X axis.\n  */\n  getX() {\n    return this.x;\n  }\n\n  /**\n  * Sets the Y component of the vector.\n  * @method\n  * @param {Float} magnitude - Vector magnitude over the Y axis.\n  */\n  setY(magnitude) {\n    this.y = magnitude;\n  }\n\n  /**\n  * Gets the Y component of the vector.\n  * @method\n  * @returns {Float} Vector magnitude over the Y axis.\n  */\n  getY() {\n    return this.y;\n  }\n\n  /**\n  * Sets the vector angle.\n  * @method\n  * @param {Float} angle - Angle in radians.\n  */\n  setAngle(angle) {\n    let length = this.getLength();\n    this.x = Math.cos(angle) * length;\n    this.y = Math.sin(angle) * length;\n  }\n\n  /**\n  * Gets the current vector's angle.\n  * @method\n  * @returns {Float} The vector's angle in radians.\n  */\n  getAngle() {\n    return Math.atan2(this.getY(), this.getX());\n  }\n\n  /**\n  * Sets the magnitude of the vector on it's current direction.\n  * @method\n  * @param {Float} length - The desired length for the vector.\n  */\n  setLength(length) {\n    let angle = this.getAngle();\n    this.x = Math.cos(angle) * length;\n    this.y = Math.sin(angle) * length;\n  }\n\n  /**\n  * Gets the current length of the vector.\n  * @method\n  * @returns {Float} The current vector's length.\n  */\n  getLength() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  /**\n  * Tells if the vector has a length different than 0.\n  * @method\n  * @returns {Boolean} True when the vector's length is different than 0, false either.\n  */\n  hasLength() {\n    return this.x !== 0 || this.y !== 0;\n  }\n\n  /**\n  * Rotates the vector by a given angle in radians.\n  * @method\n  * @param {Float} angle - The rotation angle in radians.\n  */\n  rotateBy(angle) {\n    const x = this.getX();\n    const y = this.getY();\n    this.x = x * Math.cos(angle) - y * Math.sin(angle);\n    this.y = x * Math.sin(angle) + y * Math.cos(angle);\n  }\n\n  /**\n  * Adds a given vector to the current vector, returning a new instance.\n  * @method\n  * @param {Vector} vector - A vector object.\n  * @returns {Vector} The resulting vector object.\n  */\n  add(vector) {\n    return new Vector({ x: this.x + vector.getX(), y: this.y + vector.getY() });\n  }\n\n  /**\n  * Substracts a vector to the current vector, returning a new instance.\n  * @method\n  * @param {Vector} vector - A vector object.\n  * @returns {Vector} The resulting vector object.\n  */\n  substract(vector) {\n    return new Vector({ x: this.x - vector.getX(), y: this.y - vector.getY() });\n  }\n\n  /**\n  * Muliplies the current vector by a given vector\n  * @method\n  * @param {Vector} vector - A vector object.\n  * @returns {Vector} The resulting vector object.\n  */\n  multiply(value) {\n    return new Vector({ x: this.x * value, y: this.y * value });\n  }\n\n  /**\n  * Divides the current vector by a given vector.\n  * @method\n  * @param {Vector} vector - A vector object.\n  * @returns {Vector} The resulting vector object.\n  */\n  divide(value) {\n    return new Vector({ x: this.x / value, y: this.y / value });\n  }\n\n  /**\n  * Adds a given vector to the current vector instance.\n  * @method\n  * @param {Vector} vector - A vector object.\n  */\n  addTo(vector) {\n    this.x += vector.getX();\n    this.y += vector.getY();\n  }\n\n  /**\n  * Substracts a given vector from the current vector instance.\n  * @method\n  * @param {Vector} vector - A vector object.\n  */\n  substractFrom(vector) {\n    this.x -= vector.getX();\n    this.y -= vector.getY();\n  }\n\n  /**\n  * Multiplies the current vector instance by a given vector.\n  * @method\n  * @param {Vector} vector - A vector object.\n  */\n  multiplyBy(value) {\n    this.x *= value;\n    this.y *= value;\n  }\n\n  /**\n  * Divides the current vector instance by a given vector.\n  * @method\n  * @param {Vector} vector - A vector object.\n  */\n  divideBy(value) {\n    this.x /= value;\n    this.y /= value;\n  }\n\n  /**\n  * Computes the dot product between the current instance and a given vector. Sometimes used to determine the relative position between the two vectors:<br/>&nbsp;&nbsp;<0 means B is behind<br/> &nbsp;&nbsp;=0 means B is in front<br/> &nbsp;&nbsp;>0 means B is at left/rights used to find the position of vector A with respect to vector B:<br/>\n  * @method\n  * @param {Vector} vector - A vector object.\n  * @returns {Float} The dot product between the two vectors.\n  */\n  dot(vector) {\n    return this.x * vector.x + this.y * vector.y;\n  }\n\n  /**\n  * Computes the cross product between the current instance and a given vector.\n  * @method\n  * @param {Vector} vector - A vector object.\n  * @returns {Float} The cross product between the two vectors.\n  */\n  cross(vector) {\n    return (this.x * vector.y) - (this.y * vector.x);\n  }\n\n  /**\n  * Computes the perpendicular dot product (or outer product) between two vectors to find the intersection point between the two given vectors.\n  * @method\n  * @param {Vector} vector - A vector object.\n  * @returns {Vector} A vector object representing the intersection point between the two vectors.\n  */\n  perpDot(vector) {\n    const v3 = this.substract(vector);\n    const t = v3.cross(vector) / this.cross(vector);\n    return new Vector({\n      x: this.getX() + vector.getX() * t,\n      y: this.getY() + vector.getY() * t\n    });\n  }\n\n  /**\n  * Computes the perpendicular vector from the defined from the current Vector instance to the given Vector.\n  * @method\n  * @param {Vector} vector - A vector object.\n  * @returns {Array} A an array of Vector objects (left and right)\n  */\n  perpTo(vector) {\n    const fromTarget = this.substract(vector);\n    fromTarget.normalize();\n    const perpLeft = new ddw.Vector({\n      x: fromTarget.getY(),\n      y: -fromTarget.getX(),\n      length: 1\n    });\n    const perpRight = new ddw.Vector({\n      x: -fromTarget.getY(),\n      y: fromTarget.getX(),\n      length: 1\n    });\n    return [ perpLeft, perpRight ];\n  }\n\n  /**\n  * Computes the vector projection of the current instance along the given vector.\n  * @method\n  * @param {Vector} vector - A vector object.\n  * @returns {Vector} A new vector instance representing the computed projection.\n  */\n  project(v) {\n    const d = vector.dot(vector);\n    if (d > 0) {\n      const dp = this.dot(vector);\n      const factor = dp / d;\n      const rx = vector.copy();\n      rx.multiplyBy(factor);\n      return rx;\n    }\n    return new Vector();\n  }\n\n  /**\n  * Computes the angle (in radians) formed between the current instance and a given vector.\n  * @method\n  * @param {Vector} vector - A vector object.\n  * @returns {Float} Angle in radians.\n  */\n  angleBetween(vector) {\n    let v1 = this.copy();\n    let v2 = vector.copy();\n    v1.normalize();\n    v2.normalize();\n    let dot = v1.dot(v2);\n    let theta = Math.acos(dot);\n    if (isNaN(theta)) {\n      console.warn(\"Theta is 'NaN' on Vector.angleBetween()\")\n    }\n    return theta;\n  }\n\n  /**\n  * Returns the direction of the current vector's with respect to a given vector. The result is interpreted as:<br/>&nbsp;&nbsp;=0 in front<br/>&nbsp;&nbsp;-1 to the right<br/>&nbsp;&nbsp;=1 to the left\n  * @method\n  * @param {Vector} vector - A vector object.\n  * @returns {Int} One integer of [-1, 0, 1] interpreted as \"right\", \"in front\", \"left\".\n  */\n  angleDirection(vector) {\n    let crossProduct = this.cross(vector);\n    if (crossProduct > 0.0) {\n      return 1;\n    } else if (crossProduct < 0.0) {\n      return -1;\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n  * Returns the angular difference betwee the current vector and a given vector\n  * @method\n  * @param {Vector} vector - A vector object.\n  * @returns {Float} Angle in radians.\n  */\n  angleDifference(vector) {\n    let theta = this.angleBetween(vector);\n    let dir = this.angleDirection(vector);\n    return theta * dir;\n  }\n\n  /**\n  * Creates a copy of the current instance.\n  * @method\n  * @returns {Vector} A copy of the current instance.\n  */\n  copy() {\n    return new Vector({\n      x: this.getX(),\n      y: this.getY()\n    });\n  }\n\n  /**\n  * Normalized the current vector instance converting it's magnitude to a value between 0 and 1.\n  * @method\n  */\n  normalize() {\n    var length = this.getLength();\n    if (length != 0) {\n      this.divideBy(length);\n    }\n  }\n\n  /**\n  * Computes the distance between the current instance and a given vector.\n  * @method\n  * @param {Vector} vector - A vector object.\n  * @returns {Float} The distance between the two vector.\n  */\n  dist(vector) {\n    let d = vector.substract(this);\n    return d.getLength();\n  }\n\n  /**\n  * Truncates the current instance's magnitude by a maximum value.\n  * @method\n  * @param {Float} max - The maximum magnitud for the vector's length.\n  */\n  limit(max) {\n    if (this.getLength() > max) {\n      this.setLength(max);\n    }\n  }\n\n  /**\n  * Resets the current instance's x and y components to 0.\n  * @method\n  */\n  reset() {\n    this.x = 0;\n    this.y = 0;\n  }\n\n};\n\nmodule.exports = Vector;\n","const Body = require(\"./Body\");\nconst Model = require(\"./Model\");\nconst Utils = require(\"./Utils\");\nconst Geometry = require(\"./Geometry\");\n\nclass Viewport extends Body {\n\n  constructor(settings) {\n    super({\n\t\t\t\tangle: settings.angle || 0,\n\t\t\t\tscale: settings.scale || 1,\n\t\t\t\tmodel: new Model({\n          points: [\n            [-settings.width/2, -settings.height/2],\n            [-settings.width/2,  settings.height/2],\n            [settings.width/2,   settings.height/2],\n            [settings.width/2,  -settings.height/2]\n          ]\n        })\n\t\t});\n    this.geometry = Geometry;\n    this.width = settings.width || 800;\n    this.height = settings.height || 600;\n\t\tthis.attached = settings.attachTo || false;\n    this.transitions = [];\n\t}\n\n  update() {\n\n    if (this.attached) {\n      this.location.x = this.attached.location.getX();\n      this.location.y = this.attached.location.getY();\n\n    } else {\n\n  \t\tthis.velocity.addTo(this.acceleration);\n  \t\tthis.location.addTo(this.velocity);\n  \t\tthis.acceleration.multiplyBy(0);\n      this.angleVelocity += this.angleAcceleration;\n      this.angle += this.angleVelocity;\n      this.angleAcceleration = 0;\n    }\n\n    this.world = this.getWorldTransform();\n\n    this.runTransitions();\n\t}\n\n  intersects(body) {\n    const main = this.geometry.rectangleRectangleIntersection(body.world, this.world);\n    if (main) {\n      return main;\n    }\n    if (body.world.children.length > 0) {\n      for (let i=0,len=body.world.children.length; i<len; i++) {\n        const child = body.world.children[i];\n        const itc = this.geometry.rectangleRectangleIntersection(child, this.world);\n        if (itc) {\n          return itc;\n        }\n      }\n    }\n    return false;\n  }\n\n  attachTo(body) {\n    this.attached = body;\n  }\n\n  detach() {\n    this.attached = null;\n  }\n\n  addTransition(t) {\n    this.detach();\n    this.transitions.push(t);\n  }\n\n  runTransitions() {\n    for (let i=0; i<this.transitions.length; i++) {\n\n        const t = this.transitions[i];\n\n        // Remove transition\n        if (t.steps === 0) {\n          if (typeof t.end === 'function') t.end();\n          this.transitions.splice(i, 1);\n          continue;\n        }\n\n        // Translation\n        if (t['translate']) {\n          const dir = t.translate.location.add(t.translate.velocity).substract(this.location);\n          const dist = dir.getLength();\n          const translateStep = dist / t.steps;\n          dir.normalize();\n          dir.multiplyBy(translateStep);\n          this.location.addTo(dir);\n        }\n\n        // Scale\n        if (t['scale']) {\n          const scaleStep = (t.scale - this.scale) / t.steps;\n          this.scale += scaleStep;\n        }\n\n        // Update transition state\n        t.steps--;\n    }\n  }\n\n  transitionTo(body, steps, zoom, cb) {\n    body = body || null;\n    steps = steps || 100;\n    zoom = zoom || 2;\n    cb = cb || null;\n    const t = {\n      steps,\n      translate: body,\n      scale: zoom,\n      end: cb\n    };\n    this.addTransition(t);\n  }\n\n  getRelativeView(body) {\n    const location = this.attached ? this.attached.location:this.location;\n\t\tconst t = [\n\t\t\tlocation.getX() * -1,\n\t\t\tlocation.getY() * -1\n\t\t];\n\t\tconst r = this.getAngle() * -1;\n\t\tconst s = body.getScale() / this.getScale();\n    return body.world.transformInversion(t, s, r);\n  }\n\n\trotateLeft(magnitude) {\n\t\tmagnitude = magnitude || 0.01;\n\t\tthis.angle -= magnitude;\n\t}\n\n\trotateRight(magnitude) {\n\t\tmagnitude = magnitude || 0.01;\n\t\tthis.angle += magnitude;\n\t}\n\n\tscaleUp(factor) {\n\t\tfactor = factor || 0.1;\n    this.scale += this.scale * factor;\n    this.scale += this.scale * factor;\n\t}\n\n\tscaleDown(factor) {\n\t\tfactor = factor || 0.1;\n    this.scale -= this.scale * factor;\n    this.scale -= this.scale * factor;\n\t}\n\n\tmove(x, y) {\n    if (this.attached) { return }\n\t\tthis.location.setX(this.location.getX() + x * this.scale);\n\t\tthis.location.setY(this.location.getY() + y * this.scale);\n\t}\n\n}\n\nmodule.exports = Viewport;\n"],"sourceRoot":""}